      if (result.delivered) {\n          delivered += 1;\n        }\n        return result;\n      }),\n    );\n\n    const rejected = results.filter((entry) => entry.status === 'rejected');\n    if (rejected.length > 0) {\n      console.warn('ping-opponent: unhandled errors while sending push notifications', rejected);\n    }\n  }\n\n  return jsonResponse({\n    matchId: match.id,\n    recordedAt: recorded.created_at,\n    notificationsAttempted: attempts,\n    notificationsDelivered: delivered,\n    cooldownMs: MATCH_PING_COOLDOWN_MS,\n  });\n});\n"}, {"name": "../_shared/push.ts", "content": "// @deno-types=\"https://deno.land/x/types/web-push/index.d.ts\"\nimport webpush from 'npm:web-push@^3.6.0';\n\nconst VAPID_PUBLIC_KEY = Deno.env.get('VAPID_PUBLIC_KEY');\nconst VAPID_PRIVATE_KEY = Deno.env.get('VAPID_PRIVATE_KEY');\nconst VAPID_SUBJECT = Deno.env.get('VAPID_SUBJECT') ?? 'mailto:support@example.com';\nconst MAX_PUSH_PAYLOAD_BYTES = 2048;\nconst payloadEncoder = new TextEncoder();\n\nif (VAPID_PUBLIC_KEY && VAPID_PRIVATE_KEY) {\n  webpush.setVapidDetails(VAPID_SUBJECT, VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY);\n} else {\n  console.warn('push: VAPID keys missing; notifications will be skipped');\n}\n\nexport interface StoredPushSubscription {\n  id: string;\n  endpoint: string;\n  p256dh: string;\n  auth: string;\n  encoding?: string | null;\n}\n\nexport interface PushPayload {\n  title: string;\n  body?: string;\n  tag?: string;\n  data?: Record<string, unknown>;\n  requireInteraction?: boolean;\n}\n\nexport type PushSendResult =\n  | { delivered: true }\n  | { delivered: false; reason: 'missing_vapid' | 'gone' | 'unauthorized' | 'error'; error?: unknown };\n\nconst serializePayload = (payload: PushPayload): string => {\n  const measure = (body: PushPayload) => payloadEncoder.encode(JSON.stringify(body)).length;\n  let workingPayload: PushPayload = { ...payload };\n  let byteLength = measure(workingPayload);\n\n  if (byteLength <= MAX_PUSH_PAYLOAD_BYTES) {\n    return JSON.stringify(workingPayload);\n  }\n\n  if (typeof workingPayload.body === 'string' && workingPayload.body.length > 0) {\n    const original = workingPayload.body;\n    let trimmedLength = original.length;\n    while (trimmedLength > 0) {\n      trimmedLength -= 1;\n      const nextBody = `${original.slice(0, trimmedLength)}\u2026`;\n      const candidate: PushPayload = { ...workingPayload, body: nextBody };\n      byteLength = measure(candidate);\n      if (byteLength <= MAX_PUSH_PAYLOAD_BYTES) {\n        console.warn('push: truncated notification body to satisfy payload limit', {\n          originalLength: original.length,\n          truncatedLength: nextBody.length,\n        });\n        return JSON.stringify(candidate);\n      }\n    }\n  }\n\n  if (workingPayload.data) {\n    const { data, ...rest } = workingPayload;\n    byteLength = measure(rest);\n    if (byteLength <= MAX_PUSH_PAYLOAD_BYTES) {\n      console.warn('push: removed payload data to satisfy payload limit', {\n        removedKeys: Object.keys(data ?? {}),\n      });\n      return JSON.stringify(rest);\n    }\n    workingPayload = rest;\n  }\n\n  const fallbackPayload: PushPayload = {\n    title: payload.title ?? 'Santorini',\n    body: 'Open Santorini to rejoin your match.',\n    tag: payload.tag,\n  };\n  const fallbackSerialized = JSON.stringify(fallbackPayload);\n  if (measure(fallbackPayload) <= MAX_PUSH_PAYLOAD_BYTES) {\n    console.warn('push: payload exceeded limit; sending minimal fallback payload');\n    return fallbackSerialized;\n  }\n\n  throw new Error('push_payload_too_large');\n};\n\nexport const sendPushNotification = async (\n  subscription: StoredPushSubscription,\n  payload: PushPayload,\n): Promise<PushSendResult> => {\n  if (!VAPID_PUBLIC_KEY || !VAPID_PRIVATE_KEY) {\n    return { delivered: false, reason: 'missing_vapid' };\n  }\n\n  let serializedPayload: string;\n  try {\n    serializedPayload = serializePayload(payload);\n  } catch (error) {\n    console.error('push: payload serialization failed', { error });\n    return { delivered: false, reason: 'error', error };\n  }\n\n  try {\n    await webpush.sendNotification(\n      {\n        endpoint: subscription.endpoint,\n        keys: {\n          p256dh: subscription.p256dh,\n          auth: subscription.auth,\n        },\n      },\n      serializedPayload,\n      {\n        TTL: 3600,\n      },\n    );\n    return { delivered: true };\n  } catch (error) {\n    const statusCode = typeof error === 'object' && error && 'statusCode' in error ? (error as { statusCode?: number }).statusCode : null;\n    if (statusCode === 404 || statusCode === 410) {\n      console.warn('push: subscription endpoint expired', { endpoint: subscription.endpoint, statusCode });\n      return { delivered: false, reason: 'gone' };\n    }\n    if (statusCode === 401 || statusCode === 403) {\n      console.warn('push: unauthorized when delivering notification', { endpoint: subscription.endpoint, statusCode });\n      return { delivered: false, reason: 'unauthorized', error };\n    }\n    console.error('push: failed to deliver notification', { endpoint: subscription.endpoint, error });\n    return { delivered: false, reason: 'error', error };\n  }\n};\n"}]
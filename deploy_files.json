[{"name": "index.ts", "content": "import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2.76.1';\nimport type { SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2.76.1';\nimport { sendPushNotification, type StoredPushSubscription } from '../_shared/push.ts';\n\nconst SUPABASE_URL = Deno.env.get('SUPABASE_URL');\nconst SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');\nconst APP_BASE_URL = Deno.env.get('APP_BASE_URL') ?? null;\nconst MATCH_PING_COOLDOWN_MS = 60_000;\n\nif (!SUPABASE_URL || !SERVICE_ROLE_KEY) {\n  throw new Error('Missing Supabase configuration environment variables');\n}\n\ninterface PingOpponentRequest {\n  matchId?: string;\n}\n\ninterface PlayerProfile {\n  id: string;\n  display_name: string | null;\n}\n\ninterface MatchRecord {\n  id: string;\n  status: string;\n  creator_id: string;\n  opponent_id: string | null;\n  creator?: PlayerProfile | null;\n  opponent?: PlayerProfile | null;\n}\n\ntype ServiceSupabaseClient = SupabaseClient<any, any, any>;\n\nfunction jsonResponse(body: Record<string, unknown>, init: ResponseInit = {}): Response {\n  return new Response(JSON.stringify(body), {\n    headers: {\n      'content-type': 'application/json; charset=utf-8',\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n      'Access-Control-Allow-Methods': 'POST, OPTIONS',\n    },\n    ...init,\n  });\n}\n\nconst sanitizeBaseUrl = (value: string | null): string | null => {\n  if (!value) return null;\n  try {\n    return new URL(value).href.replace(/\\/+$/, '');\n  } catch (_error) {\n    console.warn('ping-opponent: invalid APP_BASE_URL, ignoring');\n    return null;\n  }\n};\n\nconst APP_FOCUS_BASE_URL = sanitizeBaseUrl(APP_BASE_URL);\n\nconst resolveSupabase = (): ServiceSupabaseClient =>\n  createClient(SUPABASE_URL!, SERVICE_ROLE_KEY!, {\n    auth: { persistSession: false },\n  });\n\nserve(async (req) => {\n  if (req.method === 'OPTIONS') {\n    return jsonResponse({}, { status: 200 });\n  }\n\n  if (req.method !== 'POST') {\n    return new Response('Method Not Allowed', { status: 405 });\n  }\n\n  const authHeader = req.headers.get('Authorization');\n  if (!authHeader) {\n    return jsonResponse({ error: 'Missing authorization token' }, { status: 401 });\n  }\n  const token = authHeader.replace('Bearer ', '').trim();\n  if (!token) {\n    return jsonResponse({ error: 'Invalid authorization token' }, { status: 401 });\n  }\n\n  let payload: PingOpponentRequest;\n  try {\n    payload = (await req.json()) as PingOpponentRequest;\n  } catch (error) {\n    console.error('ping-opponent: invalid JSON body', error);\n    return jsonResponse({ error: 'Invalid JSON body' }, { status: 400 });\n  }\n\n  const matchId = typeof payload.matchId === 'string' && payload.matchId.trim().length > 0 ? payload.matchId.trim() : null;\n  if (!matchId) {\n    return jsonResponse({ error: 'matchId is required' }, { status: 400 });\n  }\n\n  const supabase = resolveSupabase();\n\n  const { data: authData, error: authError } = await supabase.auth.getUser(token);\n  if (authError || !authData?.user) {\n    console.error('ping-opponent: failed to authenticate user', authError);\n    return jsonResponse({ error: 'Unauthorized' }, { status: 401 });\n  }\n\n  const { data: senderProfile, error: profileError } = await supabase\n    .from('players')\n    .select('id, display_name')\n    .eq('auth_user_id', authData.user.id)\n    .maybeSingle();\n  if (profileError || !senderProfile) {\n    console.error('ping-opponent: failed to load player profile', profileError);\n    return jsonResponse({ error: 'Player profile not found' }, { status: 403 });\n  }\n\n  const { data: matchRecord, error: matchError } = await supabase\n    .from('matches')\n    .select(\n      'id, status, creator_id, opponent_id, creator:creator_id (id, display_name), opponent:opponent_id (id, display_name)',\n    )\n    .eq('id', matchId)\n    .maybeSingle();\n  if (matchError || !matchRecord) {\n    console.error('ping-opponent: match not found', matchError);\n    return jsonResponse({ error: 'Match not found' }, { status: 404 });\n  }\n\n  const match = matchRecord as MatchRecord;\n  if (match.status !== 'in_progress' || !match.opponent_id) {\n    return jsonResponse({ error: 'Ping is only available during active games' }, { status: 409 });\n  }\n\n  const isCreator = match.creator_id === senderProfile.id;\n  const isOpponent = match.opponent_id === senderProfile.id;\n  if (!isCreator && !isOpponent) {\n    return jsonResponse({ error: 'You must be a participant to ping the opponent' }, { status: 403 });\n  }\n\n  const recipientId = isCreator ? match.opponent_id : match.creator_id;\n  if (!recipientId) {\n    return jsonResponse({ error: 'Opponent profile unavailable' }, { status: 422 });\n  }\n\n  const cutoff = new Date(Date.now() - MATCH_PING_COOLDOWN_MS).toISOString();\n  const { data: recentPings, error: pingFetchError } = await supabase\n    .from('match_ping_events')\n    .select('id, created_at')\n    .eq('match_id', match.id)\n    .eq('sender_id', senderProfile.id)\n    .gte('created_at', cutoff)\n    .order('created_at', { ascending: false })\n    .limit(1);\n  if (pingFetchError) {\n    console.error('ping-opponent: failed to check rate limit', pingFetchError);\n    return jsonResponse({ error: 'Unable to evaluate rate limit' }, { status: 500 });\n  }\n\n  if (recentPings && recentPings.length > 0) {\n    const lastPingAt = recentPings[0]?.created_at ?? null;\n    const retryAfterMs =\n      lastPingAt && Number.isFinite(Date.parse(lastPingAt))\n        ? Math.max(0, MATCH_PING_COOLDOWN_MS - (Date.now() - Date.parse(lastPingAt)))\n        : MATCH_PING_COOLDOWN_MS;\n    return jsonResponse(\n      {\n        error: 'Too many pings. Please wait before notifying again.',\n        code: 'PING_RATE_LIMIT',\n        lastPingAt,\n        retryAfterMs,\n      },\n      { status: 429 },\n    );\n  }\n\n  const { data: recorded, error: recordError } = await supabase\n    .from('match_ping_events')\n    .insert({\n      match_id: match.id,\n      sender_id: senderProfile.id,\n      recipient_id: recipientId,\n    })\n    .select('id, created_at')\n    .single();\n  if (recordError || !recorded) {\n    console.error('ping-opponent: failed to record ping event', recordError);\n    return jsonResponse({ error: 'Unable to record ping request' }, { status: 500 });\n  }\n\n  const { data: subscriptions, error: subscriptionsError } = await supabase\n    .from('web_push_subscriptions')\n    .select('id, endpoint, p256dh, auth, encoding')\n    .eq('profile_id', recipientId);\n  if (subscriptionsError) {\n    console.error('ping-opponent: failed to load push subscriptions', subscriptionsError);\n    return jsonResponse({ error: 'Unable to load opponent notification targets' }, { status: 500 });\n  }\n\n  let delivered = 0;\n  const attempts = subscriptions?.length ?? 0;\n  if (subscriptions && subscriptions.length > 0) {\n    const senderName = senderProfile.display_name ?? 'Your opponent';\n    const focusUrl = APP_FOCUS_BASE_URL ? `${APP_FOCUS_BASE_URL}#play` : null;\n    const payload = {\n      title: `${senderName} pinged you`,\n      body: 'Jump back into Santorini to continue your match.',\n      tag: `match-${match.id}-ping`,\n      data: focusUrl ? { matchId: match.id, focusUrl } : { matchId: match.id },\n      requireInteraction: true,\n    };\n\n    const results = await Promise.allSettled(\n      subscriptions.map(async (subscription) => {\n        const storedSubscription = subscription as StoredPushSubscription;\n        const result = await sendPushNotification(storedSubscription, payload);\n        if (!result.delivered && (result.reason === 'gone' || result.reason === 'unauthorized')) {\n          await supabase.from('web_push_subscriptions').delete().eq('id', storedSubscription.id);\n        }\n        if (result.delivered) {\n          delivered += 1;\n        }\n        return result;\n      }),\n    );\n\n    const rejected = results.filter((entry) => entry.status === 'rejected');\n    if (rejected.length > 0) {\n      console.warn('ping-opponent: unhandled errors while sending push notifications', rejected);\n    }\n  }\n\n  return jsonResponse({\n    matchId: match.id,\n    recordedAt: recorded.created_at,\n    notificationsAttempted: attempts,\n    notificationsDelivered: delivered,\n    cooldownMs: MATCH_PING_COOLDOWN_MS,\n  });\n});\n"}, {"name": "../_shared/push.ts", "content": "// @deno-types=\"https://deno.land/x/types/web-push/index.d.ts\"\nimport webpush from 'npm:web-push@^3.6.0';\n\nconst VAPID_PUBLIC_KEY = Deno.env.get('VAPID_PUBLIC_KEY');\nconst VAPID_PRIVATE_KEY = Deno.env.get('VAPID_PRIVATE_KEY');\nconst VAPID_SUBJECT = Deno.env.get('VAPID_SUBJECT') ?? 'mailto:support@example.com';\nconst MAX_PUSH_PAYLOAD_BYTES = 2048;\nconst payloadEncoder = new TextEncoder();\n\nif (VAPID_PUBLIC_KEY && VAPID_PRIVATE_KEY) {\n  webpush.setVapidDetails(VAPID_SUBJECT, VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY);\n} else {\n  console.warn('push: VAPID keys missing; notifications will be skipped');\n}\n\nexport interface StoredPushSubscription {\n  id: string;\n  endpoint: string;\n  p256dh: string;\n  auth: string;\n  encoding?: string | null;\n}\n\nexport interface PushPayload {\n  title: string;\n  body?: string;\n  tag?: string;\n  data?: Record<string, unknown>;\n  requireInteraction?: boolean;\n}\n\nexport type PushSendResult =\n  | { delivered: true }\n  | { delivered: false; reason: 'missing_vapid' | 'gone' | 'unauthorized' | 'error'; error?: unknown };\n\nconst serializePayload = (payload: PushPayload): string => {\n  const measure = (body: PushPayload) => payloadEncoder.encode(JSON.stringify(body)).length;\n  let workingPayload: PushPayload = { ...payload };\n  let byteLength = measure(workingPayload);\n\n  if (byteLength <= MAX_PUSH_PAYLOAD_BYTES) {\n    return JSON.stringify(workingPayload);\n  }\n\n  if (typeof workingPayload.body === 'string' && workingPayload.body.length > 0) {\n    const original = workingPayload.body;\n    let trimmedLength = original.length;\n    while (trimmedLength > 0) {\n      trimmedLength -= 1;\n      const nextBody = `${original.slice(0, trimmedLength)}\u2026`;\n      const candidate: PushPayload = { ...workingPayload, body: nextBody };\n      byteLength = measure(candidate);\n      if (byteLength <= MAX_PUSH_PAYLOAD_BYTES) {\n        console.warn('push: truncated notification body to satisfy payload limit', {\n          originalLength: original.length,\n          truncatedLength: nextBody.length,\n        });\n        return JSON.stringify(candidate);\n      }\n    }\n  }\n\n  if (workingPayload.data) {\n    const { data, ...rest } = workingPayload;\n    byteLength = measure(rest);\n    if (byteLength <= MAX_PUSH_PAYLOAD_BYTES) {\n      console.warn('push: removed payload data to satisfy payload limit', {\n        removedKeys: Object.keys(data ?? {}),\n      });\n      return JSON.stringify(rest);\n    }\n    workingPayload = rest;\n  }\n\n  const fallbackPayload: PushPayload = {\n    title: payload.title ?? 'Santorini',\n    body: 'Open Santorini to rejoin your match.',\n    tag: payload.tag,\n  };\n  const fallbackSerialized = JSON.stringify(fallbackPayload);\n  if (measure(fallbackPayload) <= MAX_PUSH_PAYLOAD_BYTES) {\n    console.warn('push: payload exceeded limit; sending minimal fallback payload');\n    return fallbackSerialized;\n  }\n\n  throw new Error('push_payload_too_large');\n};\n\nexport const sendPushNotification = async (\n  subscription: StoredPushSubscription,\n  payload: PushPayload,\n): Promise<PushSendResult> => {\n  if (!VAPID_PUBLIC_KEY || !VAPID_PRIVATE_KEY) {\n    return { delivered: false, reason: 'missing_vapid' };\n  }\n\n  let serializedPayload: string;\n  try {\n    serializedPayload = serializePayload(payload);\n  } catch (error) {\n    console.error('push: payload serialization failed', { error });\n    return { delivered: false, reason: 'error', error };\n  }\n\n  try {\n    await webpush.sendNotification(\n      {\n        endpoint: subscription.endpoint,\n        keys: {\n          p256dh: subscription.p256dh,\n          auth: subscription.auth,\n        },\n      },\n      serializedPayload,\n      {\n        TTL: 3600,\n      },\n    );\n    return { delivered: true };\n  } catch (error) {\n    const statusCode = typeof error === 'object' && error && 'statusCode' in error ? (error as { statusCode?: number }).statusCode : null;\n    if (statusCode === 404 || statusCode === 410) {\n      console.warn('push: subscription endpoint expired', { endpoint: subscription.endpoint, statusCode });\n      return { delivered: false, reason: 'gone' };\n    }\n    if (statusCode === 401 || statusCode === 403) {\n      console.warn('push: unauthorized when delivering notification', { endpoint: subscription.endpoint, statusCode });\n      return { delivered: false, reason: 'unauthorized', error };\n    }\n    console.error('push: failed to deliver notification', { endpoint: subscription.endpoint, error });\n    return { delivered: false, reason: 'error', error };\n  }\n};\n"}]